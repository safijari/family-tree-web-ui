<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- Ensure mobile compatibility -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Family Tree Drawer</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { background: #f0f0f0; display: block; }
    /* Sidebar for editing node details */
    #sidebar {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      max-width: 250px;
      z-index: 10;
    }
    #sidebar input, #sidebar button, #sidebar select {
      width: 100%;
      margin-bottom: 5px;
    }
    /* Toolbar for commands */
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      z-index: 10;
    }
    #toolbar button {
      margin-bottom: 5px;
      display: block;
      width: 150px;
    }
    /* Area for JSON save/load */
    #saveLoadArea {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      display: none;
      z-index: 10;
    }
    #saveLoadArea textarea {
      width: 100%;
      height: 100px;
    }
  </style>
</head>
<body>
  <canvas id="treeCanvas"></canvas>

  <!-- Sidebar for editing the selected node -->
  <div id="sidebar" style="display:none;">
    <h3>Node Details</h3>
    <label>Name:</label>
    <input type="text" id="nodeName">
    <label>Sex:</label>
    <select id="nodeSex">
      <option value="Male">Male</option>
      <option value="Female">Female</option>
      <option value="Other">Other</option>
    </select>
    <label>Phone:</label>
    <input type="text" id="nodePhone">
    <label>Birthday:</label>
    <input type="date" id="nodeBirthday">
    <button id="deleteNode">Delete Node</button>
    <hr>
    <button id="addPartner">Add New Partner</button>
    <button id="linkExistingPartner">Link Existing Partner</button>
    <hr>
    <button id="addChild">Add New Child</button>
    <button id="linkExistingChild">Link Existing Child</button>
  </div>

  <!-- Toolbar for commands -->
  <div id="toolbar">
    <button id="newTree">New Tree</button>
    <button id="saveTree">Save Tree</button>
    <button id="loadTree">Load Tree</button>
    <button id="addNode">Add Node</button>
    <button id="importSubtree">Import Subtree</button>
    <button id="organizeTree">Organize Tree</button>
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
  </div>

  <!-- Area for JSON save/load or subtree import -->
  <div id="saveLoadArea">
    <textarea id="treeData"></textarea>
    <button id="loadTreeData">Load Data</button>
    <button id="cancelLoad">Cancel</button>
  </div>

  <script>
    /* ========= Global Variables and Initialization ========= */
    const canvas = document.getElementById('treeCanvas');
    const ctx = canvas.getContext('2d');
    let canvasWidth = window.innerWidth;
    let canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    window.addEventListener('resize', () => {
      canvasWidth = window.innerWidth;
      canvasHeight = window.innerHeight;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      draw();
    });

    // "World" view variables for an infinite canvas.
    let offsetX = -canvasWidth / 2;
    let offsetY = -canvasHeight / 2;
    let scale = 1;

    // Track the last mouse position (for adding a node at the cursor).
    let lastMousePos = null;
    canvas.addEventListener('mousemove', e => {
      lastMousePos = { x: e.offsetX, y: e.offsetY };
      if(isPanning){
        const dx = e.offsetX - panStart.x;
        const dy = e.offsetY - panStart.y;
        offsetX -= dx / scale;
        offsetY -= dy / scale;
        panStart = { x: e.offsetX, y: e.offsetY };
        draw();
      } else if(isDraggingNode && selectedNode) {
        const worldPos = screenToWorld(e.offsetX, e.offsetY);
        selectedNode.x = originalNodePos.x + (worldPos.x - dragStart.x);
        selectedNode.y = originalNodePos.y + (worldPos.y - dragStart.y);
        draw();
      }
    });

    // Utility functions to convert between world and screen coordinates.
    function worldToScreen(x, y) {
      return {
        x: (x - offsetX) * scale,
        y: (y - offsetY) * scale
      };
    }
    function screenToWorld(x, y) {
      return {
        x: x / scale + offsetX,
        y: y / scale + offsetY
      };
    }

    // Data structure for the family tree.
    let familyTree = { nodes: {} };
    let nextNodeId = 1;
    const nodeWidth = 100;
    const nodeHeight = 70;
    const margin = 10; // for collision resolution

    // Load tree and history from localStorage.
    if(localStorage.getItem("familyTree")){
      try {
        familyTree = JSON.parse(localStorage.getItem("familyTree"));
        nextNodeId = 1;
        for (const id in familyTree.nodes) {
          let nid = parseInt(id, 10);
          if(nid >= nextNodeId) nextNodeId = nid + 1;
        }
      } catch(e) {
        console.error("Error parsing stored tree:", e);
      }
    }
    let undoStack = localStorage.getItem("undoStack") ? JSON.parse(localStorage.getItem("undoStack")) : [];
    let redoStack = localStorage.getItem("redoStack") ? JSON.parse(localStorage.getItem("redoStack")) : [];

    /* ========= History Management (Undo/Redo) ========= */
    function saveHistory() {
      // Save a deep clone of familyTree.
      undoStack.push(JSON.stringify(familyTree));
      if(undoStack.length > 100) undoStack.shift();
      redoStack = []; // clear redo on new change
      localStorage.setItem("familyTree", JSON.stringify(familyTree));
      localStorage.setItem("undoStack", JSON.stringify(undoStack));
      localStorage.setItem("redoStack", JSON.stringify(redoStack));
    }
    let saveTimeout;
    function scheduleSaveHistory() {
      if(saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        saveHistory();
        saveTimeout = null;
      }, 500);
    }
    function undo() {
      if(undoStack.length > 0){
        redoStack.push(JSON.stringify(familyTree));
        let prev = undoStack.pop();
        familyTree = JSON.parse(prev);
        nextNodeId = 1;
        for (const id in familyTree.nodes) {
          let nid = parseInt(id,10);
          if(nid >= nextNodeId) nextNodeId = nid + 1;
        }
        localStorage.setItem("familyTree", JSON.stringify(familyTree));
        localStorage.setItem("undoStack", JSON.stringify(undoStack));
        localStorage.setItem("redoStack", JSON.stringify(redoStack));
        draw();
      }
    }
    function redo() {
      if(redoStack.length > 0){
        undoStack.push(JSON.stringify(familyTree));
        let nextState = redoStack.pop();
        familyTree = JSON.parse(nextState);
        nextNodeId = 1;
        for (const id in familyTree.nodes) {
          let nid = parseInt(id,10);
          if(nid >= nextNodeId) nextNodeId = nid + 1;
        }
        localStorage.setItem("familyTree", JSON.stringify(familyTree));
        localStorage.setItem("undoStack", JSON.stringify(undoStack));
        localStorage.setItem("redoStack", JSON.stringify(redoStack));
        draw();
      }
    }

    /* ========= Collision Detection & Resolution ========= */
    function isCollision(x, y, excludeId = null) {
      for (const id in familyTree.nodes) {
        if (excludeId && parseInt(id) === excludeId) continue;
        const node = familyTree.nodes[id];
        if (!(x + nodeWidth <= node.x ||
              x >= node.x + nodeWidth ||
              y + nodeHeight <= node.y ||
              y >= node.y + nodeHeight)) {
          return true;
        }
      }
      return false;
    }
    function findNonCollidingPosition(x, y, excludeId = null) {
      let newX = x, newY = y, iterations = 0;
      const maxIterations = 100;
      while(isCollision(newX, newY, excludeId) && iterations < maxIterations) {
        newX += nodeWidth + margin;
        if(newX > x + (canvasWidth / scale)) {
          newX = x;
          newY += nodeHeight + margin;
        }
        iterations++;
      }
      return [newX, newY];
    }

    /* ========= Node Creation and Manipulation ========= */
    function addNode(x, y, data = {}) {
      [x, y] = findNonCollidingPosition(x, y);
      const node = {
        id: nextNodeId++,
        name: data.name || "Name",
        sex: data.sex || "Male",
        phone: data.phone || "",
        birthday: data.birthday || "",
        x: x,
        y: y,
        partners: [],
        children: []
      };
      familyTree.nodes[node.id] = node;
      saveHistory();
      return node;
    }
    function deleteNode(node) {
      if(!node) return;
      node.partners.forEach(pid => {
        let partner = familyTree.nodes[pid];
        if(partner) {
          partner.partners = partner.partners.filter(id => id !== node.id);
        }
      });
      for (const id in familyTree.nodes) {
        let n = familyTree.nodes[id];
        n.children = n.children.filter(cid => cid !== node.id);
      }
      delete familyTree.nodes[node.id];
      if(selectedNode && selectedNode.id === node.id) {
        selectedNode = null;
        hideSidebar();
      }
      saveHistory();
    }
    function getNodeAt(worldX, worldY) {
      const nodes = Object.values(familyTree.nodes);
      for(let i = nodes.length - 1; i >= 0; i--){
        let node = nodes[i];
        if(worldX >= node.x && worldX <= node.x + nodeWidth &&
           worldY >= node.y && worldY <= node.y + nodeHeight){
          return node;
        }
      }
      return null;
    }
    function resolveCollisionForNode(node) {
      if(!node) return;
      [node.x, node.y] = findNonCollidingPosition(node.x, node.y, node.id);
    }

    /* ========= Drawing ========= */
    function draw() {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      // Draw connections.
      for (const id in familyTree.nodes) {
        let node = familyTree.nodes[id];
        node.children.forEach(childId => {
          let child = familyTree.nodes[childId];
          if(child){
            let parentScreen = worldToScreen(node.x + nodeWidth/2, node.y + nodeHeight);
            let childScreen = worldToScreen(child.x + nodeWidth/2, child.y);
            ctx.beginPath();
            ctx.moveTo(parentScreen.x, parentScreen.y);
            ctx.lineTo(childScreen.x, childScreen.y);
            ctx.strokeStyle = 'black';
            ctx.stroke();
          }
        });
        node.partners.forEach(pid => {
          if(node.id < pid){
            let partner = familyTree.nodes[pid];
            if(partner){
              let nScreen = worldToScreen(node.x + nodeWidth, node.y + nodeHeight/2);
              let pScreen = worldToScreen(partner.x, partner.y + nodeHeight/2);
              ctx.beginPath();
              ctx.moveTo(nScreen.x, nScreen.y);
              ctx.lineTo(pScreen.x, pScreen.y);
              ctx.strokeStyle = 'red';
              ctx.stroke();
            }
          }
        });
      }
      // Draw nodes.
      for (const id in familyTree.nodes) {
        let node = familyTree.nodes[id];
        let screenPos = worldToScreen(node.x, node.y);
        ctx.beginPath();
        ctx.rect(screenPos.x, screenPos.y, nodeWidth*scale, nodeHeight*scale);
        ctx.fillStyle = (selectedNode && selectedNode.id === node.id) ? '#ffffcc' : 'white';
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.stroke();
        ctx.fillStyle = 'black';
        ctx.font = (12*scale) + "px sans-serif";
        ctx.textBaseline = "top";
        let textX = screenPos.x + 5*scale;
        let textY = screenPos.y + 5*scale;
        ctx.fillText(node.name, textX, textY);
        ctx.fillText(node.sex, textX, textY + 14*scale);
        ctx.fillText(node.phone, textX, textY + 28*scale);
        ctx.fillText(node.birthday, textX, textY + 42*scale);
      }
    }

    /* ========= Organization ========= */
    function organizeTree() {
      // 1. Build union-find for partner relationships.
      let uf = {};
      function find(x) {
        if(uf[x] === undefined) { uf[x] = x; }
        if(uf[x] !== x) uf[x] = find(uf[x]);
        return uf[x];
      }
      function union(x, y) {
        let rx = find(x), ry = find(y);
        if(rx !== ry) { uf[ry] = rx; }
      }
      for (const id in familyTree.nodes) {
        let node = familyTree.nodes[id];
        if(node.partners){
          node.partners.forEach(pid => union(node.id, pid));
        }
      }
      // Build union groups.
      let groups = {};
      for (const id in familyTree.nodes) {
        let groupId = find(familyTree.nodes[id].id);
        if(!groups[groupId]) groups[groupId] = [];
        groups[groupId].push(familyTree.nodes[id].id);
      }
      // 2. Build a map of nodeId to its parents.
      let parentsMap = {};
      for (const id in familyTree.nodes) {
        let node = familyTree.nodes[id];
        node.children.forEach(childId => {
          if(!parentsMap[childId]) parentsMap[childId] = [];
          parentsMap[childId].push(node.id);
        });
      }
      // 3. For each union group, compute a generation level.
      let groupLevel = {};
      for (const gid in groups) {
        groupLevel[gid] = 0;
      }
      let changed = true;
      while(changed){
        changed = false;
        for (const gid in groups) {
          let newLevel = 0;
          groups[gid].forEach(nodeId => {
            if(parentsMap[nodeId]){
              parentsMap[nodeId].forEach(pid => {
                let pGroup = find(pid);
                newLevel = Math.max(newLevel, groupLevel[pGroup] + 1);
              });
            }
          });
          if(newLevel > groupLevel[gid]){
            groupLevel[gid] = newLevel;
            changed = true;
          }
        }
      }
      // 4. Assign each node a generation level based on its union group.
      let generation = {};
      for (const id in familyTree.nodes) {
        let gid = find(familyTree.nodes[id].id);
        generation[id] = groupLevel[gid];
      }
      // 5. Group nodes by generation.
      let levels = {};
      for (const id in familyTree.nodes) {
        let lvl = generation[id];
        if(!levels[lvl]) levels[lvl] = [];
        levels[lvl].push(familyTree.nodes[id]);
      }
      // 6. Layout each generation horizontally.
      const verticalSpacing = nodeHeight + 50;
      const horizontalSpacing = nodeWidth + 50;
      for (let lvl in levels) {
        let group = levels[lvl];
        group.sort((a,b) => a.id - b.id);
        let totalWidth = group.length * horizontalSpacing - 50;
        let startX = - totalWidth / 2;
        group.forEach((node, i) => {
          node.x = startX + i * horizontalSpacing;
          node.y = lvl * verticalSpacing;
        });
      }
      saveHistory();
      draw();
    }

    /* ========= Subtree Import ========= */
    // Import a subtree (in the same format as our familyTree object)
    function importSubtree(jsonData) {
      try {
        let subtree = JSON.parse(jsonData);
        if(!subtree.nodes){
          alert("Invalid subtree data.");
          return;
        }
        // Build a mapping from old IDs to new IDs.
        let idMap = {};
        for (const oldId in subtree.nodes) {
          let nodeData = subtree.nodes[oldId];
          // Optionally, adjust position to avoid collision:
          let [newX, newY] = findNonCollidingPosition(nodeData.x, nodeData.y);
          let newNode = {
            id: nextNodeId++,
            name: nodeData.name,
            sex: nodeData.sex,
            phone: nodeData.phone,
            birthday: nodeData.birthday,
            x: newX,
            y: newY,
            partners: [],
            children: []
          };
          familyTree.nodes[newNode.id] = newNode;
          idMap[oldId] = newNode.id;
        }
        // Update partner and children references.
        for (const oldId in subtree.nodes) {
          let nodeData = subtree.nodes[oldId];
          let newId = idMap[oldId];
          let newNode = familyTree.nodes[newId];
          if(nodeData.partners){
            nodeData.partners.forEach(pid => {
              if(idMap[pid] && !newNode.partners.includes(idMap[pid])){
                newNode.partners.push(idMap[pid]);
              }
            });
          }
          if(nodeData.children){
            nodeData.children.forEach(cid => {
              if(idMap[cid] && !newNode.children.includes(idMap[cid])){
                newNode.children.push(idMap[cid]);
              }
            });
          }
        }
        saveHistory();
        draw();
      } catch(e) {
        alert("Error importing subtree: " + e);
      }
    }

    /* ========= Sidebar for Node Editing ========= */
    const sidebar = document.getElementById('sidebar');
    const nodeNameInput = document.getElementById('nodeName');
    const nodeSexSelect = document.getElementById('nodeSex');
    const nodePhoneInput = document.getElementById('nodePhone');
    const nodeBirthdayInput = document.getElementById('nodeBirthday');
    const deleteNodeButton = document.getElementById('deleteNode');
    const addPartnerButton = document.getElementById('addPartner');
    const linkExistingPartnerButton = document.getElementById('linkExistingPartner');
    const addChildButton = document.getElementById('addChild');
    const linkExistingChildButton = document.getElementById('linkExistingChild');

    function showSidebar(node) {
      if(!node) return;
      sidebar.style.display = 'block';
      nodeNameInput.value = node.name;
      nodeSexSelect.value = node.sex;
      nodePhoneInput.value = node.phone;
      nodeBirthdayInput.value = node.birthday;
    }
    function hideSidebar() {
      sidebar.style.display = 'none';
    }
    nodeNameInput.addEventListener('input', () => {
      if(selectedNode) {
        selectedNode.name = nodeNameInput.value;
        draw();
        scheduleSaveHistory();
      }
    });
    nodeSexSelect.addEventListener('change', () => {
      if(selectedNode) {
        selectedNode.sex = nodeSexSelect.value;
        draw();
        scheduleSaveHistory();
      }
    });
    nodePhoneInput.addEventListener('input', () => {
      if(selectedNode) {
        selectedNode.phone = nodePhoneInput.value;
        draw();
        scheduleSaveHistory();
      }
    });
    nodeBirthdayInput.addEventListener('input', () => {
      if(selectedNode) {
        selectedNode.birthday = nodeBirthdayInput.value;
        draw();
        scheduleSaveHistory();
      }
    });
    deleteNodeButton.addEventListener('click', () => {
      if(selectedNode && confirm("Delete this node?")){
        deleteNode(selectedNode);
        draw();
      }
    });
    addPartnerButton.addEventListener('click', () => {
      if(selectedNode){
        const newX = selectedNode.x + nodeWidth + margin;
        const newY = selectedNode.y;
        let newNode = addNode(newX, newY);
        selectedNode.partners.push(newNode.id);
        newNode.partners.push(selectedNode.id);
        draw();
      }
    });
    linkExistingPartnerButton.addEventListener('click', () => {
      if(selectedNode){
        const excludeIds = [selectedNode.id, ...selectedNode.partners];
        const options = Object.values(familyTree.nodes).filter(n => !excludeIds.includes(n.id));
        if(options.length === 0){
          alert("No available nodes to link as partner.");
          return;
        }
        let promptMessage = "Enter the ID of the node to link as partner:\n";
        options.forEach(n => { promptMessage += n.id + ": " + n.name + "\n"; });
        let choice = prompt(promptMessage);
        if(choice){
          let chosen = options.find(n => n.id == choice);
          if(chosen){
            selectedNode.partners.push(chosen.id);
            chosen.partners.push(selectedNode.id);
            draw();
            saveHistory();
          }
        }
      }
    });
    addChildButton.addEventListener('click', () => {
      if(selectedNode){
        const newX = selectedNode.x;
        const newY = selectedNode.y + nodeHeight + margin*5;
        let newNode = addNode(newX, newY);
        selectedNode.children.push(newNode.id);
        selectedNode.partners.forEach(pid => {
          let partner = familyTree.nodes[pid];
          if(partner && !partner.children.includes(newNode.id)){
            partner.children.push(newNode.id);
          }
        });
        draw();
      }
    });
    linkExistingChildButton.addEventListener('click', () => {
      if(selectedNode){
        const excludeIds = [selectedNode.id, ...selectedNode.children];
        const options = Object.values(familyTree.nodes).filter(n => !excludeIds.includes(n.id));
        if(options.length === 0){
          alert("No available nodes to link as child.");
          return;
        }
        let promptMessage = "Enter the ID of the node to link as child:\n";
        options.forEach(n => { promptMessage += n.id + ": " + n.name + "\n"; });
        let choice = prompt(promptMessage);
        if(choice){
          let chosen = options.find(n => n.id == choice);
          if(chosen){
            selectedNode.children.push(chosen.id);
            selectedNode.partners.forEach(pid => {
              let partner = familyTree.nodes[pid];
              if(partner && !partner.children.includes(chosen.id)){
                partner.children.push(chosen.id);
              }
            });
            draw();
            saveHistory();
          }
        }
      }
    });

    /* ========= Toolbar ========= */
    const newTreeButton = document.getElementById('newTree');
    const saveTreeButton = document.getElementById('saveTree');
    const loadTreeButton = document.getElementById('loadTree');
    const addNodeButton = document.getElementById('addNode');
    const importSubtreeButton = document.getElementById('importSubtree');
    const organizeTreeButton = document.getElementById('organizeTree');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const saveLoadArea = document.getElementById('saveLoadArea');
    const treeDataTextarea = document.getElementById('treeData');
    const loadTreeDataButton = document.getElementById('loadTreeData');
    const cancelLoadButton = document.getElementById('cancelLoad');

    newTreeButton.addEventListener('click', () => {
      if(confirm("Start a new tree? Current tree will be lost.")){
        familyTree = { nodes: {} };
        nextNodeId = 1;
        selectedNode = null;
        hideSidebar();
        saveHistory();
        draw();
      }
    });
    saveTreeButton.addEventListener('click', () => {
      treeDataTextarea.value = JSON.stringify(familyTree, null, 2);
      saveLoadArea.style.display = 'block';
      // Set the loadTreeDataButton handler to simply hide the area (for saving)
      loadTreeDataButton.onclick = () => {
        saveLoadArea.style.display = 'none';
      };
    });
    loadTreeButton.addEventListener('click', () => {
      treeDataTextarea.value = "";
      saveLoadArea.style.display = 'block';
      // Assign the "load full tree" handler.
      loadTreeDataButton.onclick = () => {
        try {
          let loadedTree = JSON.parse(treeDataTextarea.value);
          if(loadedTree && loadedTree.nodes){
            familyTree = loadedTree;
            nextNodeId = 1;
            for (const id in familyTree.nodes) {
              let nid = parseInt(id, 10);
              if(nid >= nextNodeId) nextNodeId = nid + 1;
            }
            selectedNode = null;
            hideSidebar();
            saveLoadArea.style.display = 'none';
            saveHistory();
            draw();
          } else {
            alert("Invalid tree data.");
          }
        } catch(e) {
          alert("Error loading tree data: " + e);
        }
      };
    });
    cancelLoadButton.addEventListener('click', () => {
      saveLoadArea.style.display = 'none';
    });
    // "Add Node" button adds a node at the current cursor (or center)
    addNodeButton.addEventListener('click', () => {
      let pos;
      if(lastMousePos) pos = screenToWorld(lastMousePos.x, lastMousePos.y);
      else pos = { x: offsetX + canvasWidth/(2*scale), y: offsetY + canvasHeight/(2*scale) };
      let newNode = addNode(pos.x, pos.y);
      selectedNode = newNode;
      showSidebar(newNode);
      draw();
    });
    // "Import Subtree" opens the text area with instructions.
    importSubtreeButton.addEventListener('click', () => {
      treeDataTextarea.value = "Paste subtree JSON here (must include a 'nodes' object):";
      saveLoadArea.style.display = 'block';
      // Assign the "import subtree" handler.
      loadTreeDataButton.onclick = () => {
        importSubtree(treeDataTextarea.value);
        saveLoadArea.style.display = 'none';
      };
    });
    organizeTreeButton.addEventListener('click', () => {
      organizeTree();
    });
    undoBtn.addEventListener('click', () => { undo(); });
    redoBtn.addEventListener('click', () => { redo(); });

    /* ========= Mouse Event Handlers ========= */
    let isPanning = false;
    let isDraggingNode = false;
    let panStart = { x: 0, y: 0 };
    let dragStart = { x: 0, y: 0 };
    let originalNodePos = { x: 0, y: 0 };
    let selectedNode = null;
    canvas.addEventListener('mousedown', e => {
      if(e.button !== 0) return; // only left button
      const pos = { x: e.offsetX, y: e.offsetY };
      const worldPos = screenToWorld(pos.x, pos.y);
      const node = getNodeAt(worldPos.x, worldPos.y);
      if(node){
        selectedNode = node;
        showSidebar(node);
        isDraggingNode = true;
        dragStart = worldPos;
        originalNodePos = { x: node.x, y: node.y };
      } else {
        isPanning = true;
        panStart = { x: e.offsetX, y: e.offsetY };
      }
    });
    canvas.addEventListener('mouseup', e => {
      if(isDraggingNode && selectedNode){
        if(selectedNode.x !== originalNodePos.x || selectedNode.y !== originalNodePos.y){
          resolveCollisionForNode(selectedNode);
          saveHistory();
        }
      }
      isPanning = false;
      isDraggingNode = false;
      draw();
    });
    canvas.addEventListener('mouseleave', e => {
      isPanning = false;
      isDraggingNode = false;
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    /* ========= Touch Event Handlers (for mobile) ========= */
    let touchMode = null; // "pan" or "pinch"
    let lastTouchPos = null;
    let initialPinchDist = 0;
    let initialScale = 1;
    let initialOffset = { x: 0, y: 0 };
    let touchStartTime = 0;
    let touchStartPos = null;
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      if(e.touches.length === 1){
        touchMode = 'pan';
        const touch = e.touches[0];
        lastTouchPos = { x: touch.clientX, y: touch.clientY };
        touchStartTime = Date.now();
        touchStartPos = { x: touch.clientX, y: touch.clientY };
      } else if(e.touches.length === 2){
        touchMode = 'pinch';
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialPinchDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        initialScale = scale;
        initialOffset = { x: offsetX, y: offsetY };
      }
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if(touchMode === 'pan' && e.touches.length === 1){
        const touch = e.touches[0];
        const dx = touch.clientX - lastTouchPos.x;
        const dy = touch.clientY - lastTouchPos.y;
        offsetX -= dx / scale;
        offsetY -= dy / scale;
        lastTouchPos = { x: touch.clientX, y: touch.clientY };
        draw();
      } else if(touchMode === 'pinch' && e.touches.length === 2){
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        const zoomFactor = currentDist / initialPinchDist;
        scale = initialScale * zoomFactor;
        draw();
      }
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
      if(touchMode === 'pan' && e.touches.length === 0){
        const touchDuration = Date.now() - touchStartTime;
        if(touchDuration < 300 && touchStartPos){
          const worldPos = screenToWorld(touchStartPos.x, touchStartPos.y);
          const node = getNodeAt(worldPos.x, worldPos.y);
          if(node){
            selectedNode = node;
            showSidebar(node);
          } else {
            let newNode = addNode(worldPos.x, worldPos.y);
            selectedNode = newNode;
            showSidebar(newNode);
          }
          draw();
        }
        touchMode = null;
      } else if(touchMode === 'pinch' && e.touches.length < 2){
        touchMode = null;
      }
    });

    /* ========= Initial Draw ========= */
    draw();
  </script>
</body>
</html>