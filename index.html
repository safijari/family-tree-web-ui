<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- Ensure mobile compatibility -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Family Tree Drawer</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { background: #f0f0f0; display: block; }
    /* Sidebar for editing node details */
    #sidebar {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      max-width: 250px;
      z-index: 10;
    }
    #sidebar input, #sidebar button, #sidebar select {
      width: 100%;
      margin-bottom: 5px;
    }
    /* Toolbar for commands */
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      z-index: 10;
    }
    #toolbar button {
      margin-bottom: 5px;
      display: block;
      width: 150px;
    }
    /* Area for pasting/loading JSON data */
    #saveLoadArea {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      display: none;
      z-index: 10;
    }
    #saveLoadArea textarea {
      width: 100%;
      height: 100px;
    }
  </style>
</head>
<body>
  <canvas id="treeCanvas"></canvas>

  <!-- Sidebar for editing the selected node -->
  <div id="sidebar" style="display:none;">
    <h3>Node Details</h3>
    <label>Name:</label>
    <input type="text" id="nodeName">
    <label>Sex:</label>
    <select id="nodeSex">
      <option value="Male">Male</option>
      <option value="Female">Female</option>
      <option value="Other">Other</option>
    </select>
    <label>Phone:</label>
    <input type="text" id="nodePhone">
    <label>Birthday:</label>
    <input type="date" id="nodeBirthday">
    <button id="deleteNode">Delete Node</button>
    <hr>
    <button id="addPartner">Add New Partner</button>
    <button id="linkExistingPartner">Link Existing Partner</button>
    <hr>
    <button id="addChild">Add New Child</button>
    <button id="linkExistingChild">Link Existing Child</button>
  </div>

  <!-- Toolbar for commands -->
  <div id="toolbar">
    <button id="newTree">New Tree</button>
    <button id="saveTree">Save Tree</button>
    <button id="loadTree">Load Tree</button>
    <button id="addNode">Add Node</button>
    <button id="organizeTree">Organize Tree</button>
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
  </div>

  <!-- Area for JSON save/load -->
  <div id="saveLoadArea">
    <textarea id="treeData"></textarea>
    <button id="loadTreeData">Load Data</button>
    <button id="cancelLoad">Cancel</button>
  </div>

  <script>
    /* ========= Global Variables and Initialization ========= */
    const canvas = document.getElementById('treeCanvas');
    const ctx = canvas.getContext('2d');
    let canvasWidth = window.innerWidth;
    let canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    window.addEventListener('resize', () => {
      canvasWidth = window.innerWidth;
      canvasHeight = window.innerHeight;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      draw();
    });

    // "World" view variables (for an "infinite" canvas)
    let offsetX = -canvasWidth / 2;
    let offsetY = -canvasHeight / 2;
    let scale = 1;

    // Track the last mouse position (for "Add Node" placement)
    let lastMousePos = null;
    canvas.addEventListener('mousemove', e => {
      lastMousePos = { x: e.offsetX, y: e.offsetY };
      // If panning or dragging, that is handled below.
      if(isPanning){
        const dx = e.offsetX - panStart.x;
        const dy = e.offsetY - panStart.y;
        offsetX -= dx / scale;
        offsetY -= dy / scale;
        panStart = { x: e.offsetX, y: e.offsetY };
        draw();
      } else if(isDraggingNode && selectedNode) {
        const worldPos = screenToWorld(e.offsetX, e.offsetY);
        selectedNode.x = originalNodePos.x + (worldPos.x - dragStart.x);
        selectedNode.y = originalNodePos.y + (worldPos.y - dragStart.y);
        draw();
      }
    });

    // Utility functions to convert coordinates.
    function worldToScreen(x, y) {
      return {
        x: (x - offsetX) * scale,
        y: (y - offsetY) * scale
      };
    }
    function screenToWorld(x, y) {
      return {
        x: x / scale + offsetX,
        y: y / scale + offsetY
      };
    }

    // Data structure for the family tree.
    // Each node has id, name, sex, phone, birthday, x/y coordinates,
    // plus arrays for partner and child node IDs.
    let familyTree = { nodes: {} };
    let nextNodeId = 1;
    const nodeWidth = 100;
    const nodeHeight = 70;
    const margin = 10; // used in collision resolution

    // Try to load tree and history from localStorage.
    if(localStorage.getItem("familyTree")){
      try {
        familyTree = JSON.parse(localStorage.getItem("familyTree"));
        // Update nextNodeId from loaded data.
        nextNodeId = 1;
        for (const id in familyTree.nodes) {
          let nid = parseInt(id, 10);
          if(nid >= nextNodeId) nextNodeId = nid + 1;
        }
      } catch(e) {
        console.error("Error parsing stored tree:", e);
      }
    }
    let undoStack = localStorage.getItem("undoStack") ? JSON.parse(localStorage.getItem("undoStack")) : [];
    let redoStack = localStorage.getItem("redoStack") ? JSON.parse(localStorage.getItem("redoStack")) : [];

    /* ========= History Management (Undo/Redo) ========= */
    function saveHistory() {
      // Save a deep clone (JSON string) of familyTree.
      undoStack.push(JSON.stringify(familyTree));
      if(undoStack.length > 100) undoStack.shift();
      redoStack = []; // clear redo on new change
      localStorage.setItem("familyTree", JSON.stringify(familyTree));
      localStorage.setItem("undoStack", JSON.stringify(undoStack));
      localStorage.setItem("redoStack", JSON.stringify(redoStack));
    }
    // For rapid changes (like typing), use a debounce.
    let saveTimeout;
    function scheduleSaveHistory() {
      if(saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        saveHistory();
        saveTimeout = null;
      }, 500);
    }
    function undo() {
      if(undoStack.length > 0){
        redoStack.push(JSON.stringify(familyTree));
        let prev = undoStack.pop();
        familyTree = JSON.parse(prev);
        // Recompute nextNodeId.
        nextNodeId = 1;
        for (const id in familyTree.nodes) {
          let nid = parseInt(id,10);
          if(nid >= nextNodeId) nextNodeId = nid + 1;
        }
        localStorage.setItem("familyTree", JSON.stringify(familyTree));
        localStorage.setItem("undoStack", JSON.stringify(undoStack));
        localStorage.setItem("redoStack", JSON.stringify(redoStack));
        draw();
      }
    }
    function redo() {
      if(redoStack.length > 0){
        undoStack.push(JSON.stringify(familyTree));
        let nextState = redoStack.pop();
        familyTree = JSON.parse(nextState);
        nextNodeId = 1;
        for (const id in familyTree.nodes) {
          let nid = parseInt(id,10);
          if(nid >= nextNodeId) nextNodeId = nid + 1;
        }
        localStorage.setItem("familyTree", JSON.stringify(familyTree));
        localStorage.setItem("undoStack", JSON.stringify(undoStack));
        localStorage.setItem("redoStack", JSON.stringify(redoStack));
        draw();
      }
    }

    /* ========= Collision Detection & Resolution ========= */
    // Returns true if the rectangle at (x,y) overlaps any other node (except excludeId).
    function isCollision(x, y, excludeId = null) {
      for (const id in familyTree.nodes) {
        if (excludeId && parseInt(id) === excludeId) continue;
        const node = familyTree.nodes[id];
        if (!(x + nodeWidth <= node.x ||
              x >= node.x + nodeWidth ||
              y + nodeHeight <= node.y ||
              y >= node.y + nodeHeight)) {
          return true;
        }
      }
      return false;
    }
    // Given (x,y), find a nearby position that does not collide.
    function findNonCollidingPosition(x, y, excludeId = null) {
      let newX = x, newY = y, iterations = 0;
      const maxIterations = 100;
      while(isCollision(newX, newY, excludeId) && iterations < maxIterations) {
        newX += nodeWidth + margin;
        if(newX > x + (canvasWidth / scale)) {
          newX = x;
          newY += nodeHeight + margin;
        }
        iterations++;
      }
      return [newX, newY];
    }

    /* ========= Node Creation and Manipulation ========= */
    // Create a new node at (x,y) (adjusting to avoid collisions).
    function addNode(x, y, data = {}) {
      [x, y] = findNonCollidingPosition(x, y);
      const node = {
        id: nextNodeId++,
        name: data.name || "Name",
        sex: data.sex || "Male",
        phone: data.phone || "",
        birthday: data.birthday || "",
        x: x,
        y: y,
        partners: [],
        children: []
      };
      familyTree.nodes[node.id] = node;
      saveHistory();
      return node;
    }
    // Remove a node and its references.
    function deleteNode(node) {
      if(!node) return;
      node.partners.forEach(pid => {
        let partner = familyTree.nodes[pid];
        if(partner) {
          partner.partners = partner.partners.filter(id => id !== node.id);
        }
      });
      for (const id in familyTree.nodes) {
        let n = familyTree.nodes[id];
        n.children = n.children.filter(cid => cid !== node.id);
      }
      delete familyTree.nodes[node.id];
      if(selectedNode && selectedNode.id === node.id) {
        selectedNode = null;
        hideSidebar();
      }
      saveHistory();
    }
    // Return node at given world coordinates.
    function getNodeAt(worldX, worldY) {
      const nodes = Object.values(familyTree.nodes);
      for(let i = nodes.length - 1; i >= 0; i--){
        let node = nodes[i];
        if(worldX >= node.x && worldX <= node.x + nodeWidth &&
           worldY >= node.y && worldY <= node.y + nodeHeight){
          return node;
        }
      }
      return null;
    }
    // After dragging, resolve any collisions.
    function resolveCollisionForNode(node) {
      if(!node) return;
      [node.x, node.y] = findNonCollidingPosition(node.x, node.y, node.id);
    }

    /* ========= Drawing ========= */
    function draw() {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      // Draw connections first.
      for (const id in familyTree.nodes) {
        let node = familyTree.nodes[id];
        // Parent-to-child lines.
        node.children.forEach(childId => {
          let child = familyTree.nodes[childId];
          if(child){
            let parentScreen = worldToScreen(node.x + nodeWidth/2, node.y + nodeHeight);
            let childScreen = worldToScreen(child.x + nodeWidth/2, child.y);
            ctx.beginPath();
            ctx.moveTo(parentScreen.x, parentScreen.y);
            ctx.lineTo(childScreen.x, childScreen.y);
            ctx.strokeStyle = 'black';
            ctx.stroke();
          }
        });
        // Partner lines (draw each only once).
        node.partners.forEach(pid => {
          if(node.id < pid){
            let partner = familyTree.nodes[pid];
            if(partner){
              let nScreen = worldToScreen(node.x + nodeWidth, node.y + nodeHeight/2);
              let pScreen = worldToScreen(partner.x, partner.y + nodeHeight/2);
              ctx.beginPath();
              ctx.moveTo(nScreen.x, nScreen.y);
              ctx.lineTo(pScreen.x, pScreen.y);
              ctx.strokeStyle = 'red';
              ctx.stroke();
            }
          }
        });
      }
      // Draw nodes.
      for (const id in familyTree.nodes) {
        let node = familyTree.nodes[id];
        let screenPos = worldToScreen(node.x, node.y);
        ctx.beginPath();
        ctx.rect(screenPos.x, screenPos.y, nodeWidth*scale, nodeHeight*scale);
        ctx.fillStyle = (selectedNode && selectedNode.id === node.id) ? '#ffffcc' : 'white';
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.stroke();
        // Draw text.
        ctx.fillStyle = 'black';
        ctx.font = (12*scale) + "px sans-serif";
        ctx.textBaseline = "top";
        let textX = screenPos.x + 5*scale;
        let textY = screenPos.y + 5*scale;
        ctx.fillText(node.name, textX, textY);
        ctx.fillText(node.sex, textX, textY + 14*scale);
        ctx.fillText(node.phone, textX, textY + 28*scale);
        ctx.fillText(node.birthday, textX, textY + 42*scale);
      }
    }

    /* ========= Organization ========= */
    // A simple layout that assigns generation levels (parents above children)
    // and groups nodes with partner relationships in each level.
    function organizeTree() {
      const nodesArr = Object.values(familyTree.nodes);
      // Determine which nodes are children (appear in any children array)
      let childSet = new Set();
      nodesArr.forEach(n => n.children.forEach(cid => childSet.add(cid)));
      // Compute generation levels (roots are level 0)
      let generation = {};
      nodesArr.forEach(n => {
        if(!childSet.has(n.id)) generation[n.id] = 0;
        else generation[n.id] = 0; // initialize
      });
      let changed = true;
      while(changed){
        changed = false;
        nodesArr.forEach(n => {
          let g = generation[n.id];
          n.children.forEach(cid => {
            if(generation[cid] < g + 1){
              generation[cid] = g + 1;
              changed = true;
            }
          });
        });
      }
      // Group nodes by generation.
      let groups = {};
      nodesArr.forEach(n => {
        let g = generation[n.id];
        if(!groups[g]) groups[g] = [];
        groups[g].push(n);
      });
      // Layout each generation.
      const verticalSpacing = nodeHeight + 50;
      const startY = 0;
      const clusterMargin = 50;
      const levels = Object.keys(groups).map(Number).sort((a, b) => a - b);
      levels.forEach(level => {
        let group = groups[level];
        // Cluster nodes in this level by partner relationships.
        let clusters = [];
        let visited = new Set();
        group.forEach(node => {
          if(visited.has(node.id)) return;
          let cluster = [];
          function dfs(n) {
            if(visited.has(n.id)) return;
            visited.add(n.id);
            cluster.push(n);
            n.partners.forEach(pid => {
              let partner = familyTree.nodes[pid];
              if(partner && group.includes(partner)) dfs(partner);
            });
          }
          dfs(node);
          clusters.push(cluster);
        });
        // Compute total width needed.
        let totalWidth = 0;
        let clusterWidths = [];
        clusters.forEach(cl => {
          let w = cl.length * (nodeWidth + margin) - margin;
          clusterWidths.push(w);
          totalWidth += w;
        });
        totalWidth += (clusters.length - 1) * clusterMargin;
        let currentX = -totalWidth / 2;
        clusters.forEach((cluster, idx) => {
          cluster.sort((a,b) => a.id - b.id);
          let clusterWidth = cluster.length * (nodeWidth + margin) - margin;
          cluster.forEach((node, i) => {
            node.x = currentX + i * (nodeWidth + margin);
            node.y = startY + level * verticalSpacing;
          });
          currentX += clusterWidth + clusterMargin;
        });
      });
      saveHistory();
      draw();
    }

    /* ========= Sidebar for Node Editing ========= */
    const sidebar = document.getElementById('sidebar');
    const nodeNameInput = document.getElementById('nodeName');
    const nodeSexSelect = document.getElementById('nodeSex');
    const nodePhoneInput = document.getElementById('nodePhone');
    const nodeBirthdayInput = document.getElementById('nodeBirthday');
    const deleteNodeButton = document.getElementById('deleteNode');
    const addPartnerButton = document.getElementById('addPartner');
    const linkExistingPartnerButton = document.getElementById('linkExistingPartner');
    const addChildButton = document.getElementById('addChild');
    const linkExistingChildButton = document.getElementById('linkExistingChild');

    function showSidebar(node) {
      if(!node) return;
      sidebar.style.display = 'block';
      nodeNameInput.value = node.name;
      nodeSexSelect.value = node.sex;
      nodePhoneInput.value = node.phone;
      nodeBirthdayInput.value = node.birthday;
    }
    function hideSidebar() {
      sidebar.style.display = 'none';
    }
    nodeNameInput.addEventListener('input', () => {
      if(selectedNode) {
        selectedNode.name = nodeNameInput.value;
        draw();
        scheduleSaveHistory();
      }
    });
    nodeSexSelect.addEventListener('change', () => {
      if(selectedNode) {
        selectedNode.sex = nodeSexSelect.value;
        draw();
        scheduleSaveHistory();
      }
    });
    nodePhoneInput.addEventListener('input', () => {
      if(selectedNode) {
        selectedNode.phone = nodePhoneInput.value;
        draw();
        scheduleSaveHistory();
      }
    });
    nodeBirthdayInput.addEventListener('input', () => {
      if(selectedNode) {
        selectedNode.birthday = nodeBirthdayInput.value;
        draw();
        scheduleSaveHistory();
      }
    });
    deleteNodeButton.addEventListener('click', () => {
      if(selectedNode && confirm("Delete this node?")){
        deleteNode(selectedNode);
        draw();
      }
    });
    // "Add New Partner" creates a new node to the right and links it.
    addPartnerButton.addEventListener('click', () => {
      if(selectedNode){
        const newX = selectedNode.x + nodeWidth + margin;
        const newY = selectedNode.y;
        let newNode = addNode(newX, newY);
        selectedNode.partners.push(newNode.id);
        newNode.partners.push(selectedNode.id);
        draw();
      }
    });
    // "Link Existing Partner" prompts the user to enter an ID.
    linkExistingPartnerButton.addEventListener('click', () => {
      if(selectedNode){
        const excludeIds = [selectedNode.id, ...selectedNode.partners];
        const options = Object.values(familyTree.nodes).filter(n => !excludeIds.includes(n.id));
        if(options.length === 0){
          alert("No available nodes to link as partner.");
          return;
        }
        let promptMessage = "Enter the ID of the node to link as partner:\n";
        options.forEach(n => { promptMessage += n.id + ": " + n.name + "\n"; });
        let choice = prompt(promptMessage);
        if(choice){
          let chosen = options.find(n => n.id == choice);
          if(chosen){
            selectedNode.partners.push(chosen.id);
            chosen.partners.push(selectedNode.id);
            draw();
            saveHistory();
          }
        }
      }
    });
    // "Add New Child" creates a new node below and links it.
    addChildButton.addEventListener('click', () => {
      if(selectedNode){
        const newX = selectedNode.x;
        const newY = selectedNode.y + nodeHeight + margin*5;
        let newNode = addNode(newX, newY);
        selectedNode.children.push(newNode.id);
        selectedNode.partners.forEach(pid => {
          let partner = familyTree.nodes[pid];
          if(partner && !partner.children.includes(newNode.id)){
            partner.children.push(newNode.id);
          }
        });
        draw();
      }
    });
    // "Link Existing Child" prompts for an existing node ID.
    linkExistingChildButton.addEventListener('click', () => {
      if(selectedNode){
        const excludeIds = [selectedNode.id, ...selectedNode.children];
        const options = Object.values(familyTree.nodes).filter(n => !excludeIds.includes(n.id));
        if(options.length === 0){
          alert("No available nodes to link as child.");
          return;
        }
        let promptMessage = "Enter the ID of the node to link as child:\n";
        options.forEach(n => { promptMessage += n.id + ": " + n.name + "\n"; });
        let choice = prompt(promptMessage);
        if(choice){
          let chosen = options.find(n => n.id == choice);
          if(chosen){
            selectedNode.children.push(chosen.id);
            selectedNode.partners.forEach(pid => {
              let partner = familyTree.nodes[pid];
              if(partner && !partner.children.includes(chosen.id)){
                partner.children.push(chosen.id);
              }
            });
            draw();
            saveHistory();
          }
        }
      }
    });

    /* ========= Toolbar (New, Save, Load, Add Node, Organize, Undo/Redo) ========= */
    const newTreeButton = document.getElementById('newTree');
    const saveTreeButton = document.getElementById('saveTree');
    const loadTreeButton = document.getElementById('loadTree');
    const addNodeButton = document.getElementById('addNode');
    const organizeTreeButton = document.getElementById('organizeTree');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const saveLoadArea = document.getElementById('saveLoadArea');
    const treeDataTextarea = document.getElementById('treeData');
    const loadTreeDataButton = document.getElementById('loadTreeData');
    const cancelLoadButton = document.getElementById('cancelLoad');

    newTreeButton.addEventListener('click', () => {
      if(confirm("Start a new tree? Current tree will be lost.")){
        familyTree = { nodes: {} };
        nextNodeId = 1;
        selectedNode = null;
        hideSidebar();
        saveHistory();
        draw();
      }
    });
    saveTreeButton.addEventListener('click', () => {
      treeDataTextarea.value = JSON.stringify(familyTree, null, 2);
      saveLoadArea.style.display = 'block';
    });
    loadTreeButton.addEventListener('click', () => {
      treeDataTextarea.value = "";
      saveLoadArea.style.display = 'block';
    });
    loadTreeDataButton.addEventListener('click', () => {
      try {
        let loadedTree = JSON.parse(treeDataTextarea.value);
        if(loadedTree && loadedTree.nodes){
          familyTree = loadedTree;
          nextNodeId = 1;
          for (const id in familyTree.nodes) {
            let nid = parseInt(id, 10);
            if(nid >= nextNodeId) nextNodeId = nid + 1;
          }
          selectedNode = null;
          hideSidebar();
          saveLoadArea.style.display = 'none';
          saveHistory();
          draw();
        } else {
          alert("Invalid tree data.");
        }
      } catch(e) {
        alert("Error loading tree data: " + e);
      }
    });
    cancelLoadButton.addEventListener('click', () => {
      saveLoadArea.style.display = 'none';
    });
    addNodeButton.addEventListener('click', () => {
      // Add a node at lastMousePos (if available) or at canvas center.
      let pos;
      if(lastMousePos) pos = screenToWorld(lastMousePos.x, lastMousePos.y);
      else pos = { x: offsetX + canvasWidth/(2*scale), y: offsetY + canvasHeight/(2*scale) };
      let newNode = addNode(pos.x, pos.y);
      selectedNode = newNode;
      showSidebar(newNode);
      draw();
    });
    organizeTreeButton.addEventListener('click', () => {
      organizeTree();
    });
    undoBtn.addEventListener('click', () => { undo(); });
    redoBtn.addEventListener('click', () => { redo(); });

    /* ========= Mouse Event Handlers ========= */
    // Left-click: if on a node, select and (optionally) drag it;
    // if not on a node, begin panning.
    let isPanning = false;
    let isDraggingNode = false;
    let panStart = { x: 0, y: 0 };
    let dragStart = { x: 0, y: 0 };
    let originalNodePos = { x: 0, y: 0 };

    canvas.addEventListener('mousedown', e => {
      // Left button only.
      if(e.button !== 0) return;
      const pos = { x: e.offsetX, y: e.offsetY };
      const worldPos = screenToWorld(pos.x, pos.y);
      const node = getNodeAt(worldPos.x, worldPos.y);
      if(node){
        // Select node and start dragging.
        selectedNode = node;
        showSidebar(node);
        isDraggingNode = true;
        dragStart = worldPos;
        originalNodePos = { x: node.x, y: node.y };
      } else {
        // Start panning.
        isPanning = true;
        panStart = { x: e.offsetX, y: e.offsetY };
      }
    });
    canvas.addEventListener('mouseup', e => {
      if(isDraggingNode && selectedNode){
        // On finishing drag, resolve collisions.
        if(selectedNode.x !== originalNodePos.x || selectedNode.y !== originalNodePos.y){
          resolveCollisionForNode(selectedNode);
          saveHistory();
        }
      }
      isPanning = false;
      isDraggingNode = false;
      draw();
    });
    canvas.addEventListener('mouseleave', e => {
      isPanning = false;
      isDraggingNode = false;
    });
    // Prevent context menu.
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    /* ========= Touch Event Handlers (for mobile) ========= */
    let touchMode = null; // "pan" or "pinch"
    let lastTouchPos = null;
    let initialPinchDist = 0;
    let initialScale = 1;
    let initialOffset = { x: 0, y: 0 };
    let touchStartTime = 0;
    let touchStartPos = null;
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      if(e.touches.length === 1){
        touchMode = 'pan';
        const touch = e.touches[0];
        lastTouchPos = { x: touch.clientX, y: touch.clientY };
        touchStartTime = Date.now();
        touchStartPos = { x: touch.clientX, y: touch.clientY };
      } else if(e.touches.length === 2){
        touchMode = 'pinch';
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialPinchDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        initialScale = scale;
        initialOffset = { x: offsetX, y: offsetY };
      }
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if(touchMode === 'pan' && e.touches.length === 1){
        const touch = e.touches[0];
        const dx = touch.clientX - lastTouchPos.x;
        const dy = touch.clientY - lastTouchPos.y;
        offsetX -= dx / scale;
        offsetY -= dy / scale;
        lastTouchPos = { x: touch.clientX, y: touch.clientY };
        draw();
      } else if(touchMode === 'pinch' && e.touches.length === 2){
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        const zoomFactor = currentDist / initialPinchDist;
        scale = initialScale * zoomFactor;
        draw();
      }
    }, { passive: false });
    canvas.addEventListener('touchend', e => {
      if(touchMode === 'pan' && e.touches.length === 0){
        const touchDuration = Date.now() - touchStartTime;
        if(touchDuration < 300 && touchStartPos){
          const worldPos = screenToWorld(touchStartPos.x, touchStartPos.y);
          const node = getNodeAt(worldPos.x, worldPos.y);
          if(node){
            selectedNode = node;
            showSidebar(node);
          } else {
            let newNode = addNode(worldPos.x, worldPos.y);
            selectedNode = newNode;
            showSidebar(newNode);
          }
          draw();
        }
        touchMode = null;
      } else if(touchMode === 'pinch' && e.touches.length < 2){
        touchMode = null;
      }
    });

    /* ========= Initial Draw ========= */
    draw();
  </script>
</body>
</html>
